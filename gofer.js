import RSS from 'rss-generator';
import { Chapter } from './db.js';
import fs from 'fs';
import chalk from 'chalk';

const gofers = [];
// get gofers in the folder excluding factories
const goferFiles = fs.readdirSync('./gofers').filter((i) => !i.startsWith('_'));
for (let g of goferFiles) {
	const module = await import('./gofers/' + g);
	gofers.push(module.default);
	console.log(chalk.cyan('[GOFR]') + ' Found gofer: ' + module.default.manga);
}

function CrawlError(message = '') {
    this.name = 'CrawlError';
    this.message = message;
}; CrawlError.prototype = Error.prototype;

// Tell gofer to crawl for chapters
async function crawlChapters(gofer) {
	let retries = 3;
	let chapters = [];
	while (chapters.length < 1) {
		console.log(chalk.blue('[GOFR]') + ` ${gofer.manga}: Crawling for chapters... (${retries} retries remaining)`);
		try {
			chapters = await gofer.crawl();
		} catch (e) {
			throw new CrawlError(`Failed fetching ${gofer.manga} chapters. (${e.message})`);
		}
		retries -= 1;
		if (retries < 0) {
			throw new CrawlError(`Could not get ${gofer.manga} chapters.`);
		}
	}

	return chapters;
};

// Save chapters to DB (without overwriting older entries)
async function saveChapters(chapters) {
	for (let chapter of chapters) {
		const find = await Chapter.findOne({ where: { manga: chapter.manga, title: chapter.title }});
		if (!find) {
			await Chapter.create(chapter);
		}
	}
};

// Load chapters from DB
async function loadChapters(gofer) {
	return await Chapter.findAll({ where: { manga: gofer.manga },
		order: gofer.order ?? [
			['date', 'DESC'],
			['createdAt', 'DESC'],
			['title', 'DESC'],
		]
	});
};

// Generate and save RSS file
function generateRSS(gofer, chapters) {
	const feed = new RSS({
		title: gofer.manga,
		description: `${gofer.manga} chapters automatically generated by crawling.`,
		site_url: gofer.url,
	});

	for (let i in chapters) {
		let chapter = chapters[i];
		chapter.guid = chapters[i].id;
		delete chapter.manga;
		if (!chapter.date) {
			chapter.date = chapter.createdAt;
		}

		feed.item(chapter);
	}
	
	return fs.writeFileSync(`./rss/${gofer.manga}.rss`, feed.xml());
};

// Begin
export default () => {
	return new Promise((finish) => {
		const promises = new Array();
		for(let gofer of gofers) {
			promises.push(new Promise(async (resolve, reject) => {
				let chapters;
				try {
					chapters = await crawlChapters(gofer);
				} catch(e) {
					if (e instanceof CrawlError) {
						console.error(chalk.blue('[GOFR]') + ' ' + chalk.red(e.message));
						return reject(e);
					} else {
						throw e;
					}
				}
		
				console.log(chalk.blue('[GOFR]') + ` ${gofer.manga}: Saving retrieved ${chapters.length} chapter(s) to database...`);
				await saveChapters(chapters);
		
				console.log(chalk.blue('[GOFR]') + ` ${gofer.manga}: Loading all saved chapters from database...`);
				chapters = await loadChapters(gofer);
				
				console.log(chalk.blue('[GOFR]') + ` ${gofer.manga}: Generating RSS file...`);
				generateRSS(gofer, chapters);
		
				console.log(chalk.blue('[GOFR]') + ` ${gofer.manga}: RSS file created.`);
				resolve();
			}));
		}
		
		Promise.allSettled(promises).then(() => {
			console.log(chalk.cyan('[GOFR]') + ' Finished generating all RSS files.');
			finish();
		});
	});
};
